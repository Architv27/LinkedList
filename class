#include <iostream>
#include <iomanip>
#include <string>
#include <typeinfo>
#include <ctime>
#include<cmath>

using namespace std;

class Shape
{
private:
	string color;
	static int count;
public:
	static double const PI; //Value of PI for later use
public:
	Shape() { color = "None"; count++; }
	Shape(const string& c) { color = c; count++; }
	Shape(const Shape& s) { color = s.getColor(); count++; }

	virtual ~Shape() { count--; }

	string getColor() const { return color; }
	static int getCount() { return count; }

	void setColor(const string& c) { color = c; }

	virtual double getArea() const = 0;
	virtual double getPerimeter() const = 0;
	string getType() const
	{
		string s = typeid(*this).name();	//Now s is "class CLASSNAME"
		return s.substr(1);					//returning CLASSNAME
	}

	virtual void readInfo(istream&) = 0;
	virtual void printInfo(ostream&) const = 0;

	friend istream& operator>>(istream& in, Shape& s)
	{
		s.readInfo(in);
		return in;
	}
	friend ostream& operator<<(ostream& out, const Shape& s)
	{
		out.setf(ios::fixed | ios::left);	//Left aligned fixed decimal places
		s.printInfo(out);
		out.unsetf(ios::fixed | ios::left);	//Removing formatting
		cout.precision(0);					//Resetting the decimal places
		return out;
	}
};
int Shape::count = 0;
double const Shape::PI = 3.14159265359;
typedef Shape* ShapePtr;

class Rectangle : public Shape
{
private:
	double length, width;
public:
	Rectangle();
	Rectangle(const double&, const double&, const string&);

	double getLength() const;
	double getWidth() const;

	virtual void setLength(const double&);
	virtual void setWidth(const double&);

	virtual double getArea() const;
	virtual double getPerimeter() const;

	virtual void readInfo(istream&);
	virtual void printInfo(ostream&) const;
};

Rectangle::Rectangle() : Shape()
{
	length = 0;
	width = 0;
}
Rectangle::Rectangle(const double& len, const double& wid, const string& c) : Shape(c)
{
	length = len;
	width = wid;
}
double Rectangle::getLength() const { return length; }
double Rectangle::getWidth() const { return width; }
void Rectangle::setLength(const double& len) { length = len; }
void Rectangle::setWidth(const double& wid) { width = wid; }
double Rectangle::getArea() const { return length*width; }
double Rectangle::getPerimeter() const { return 2*(length+width); }
void Rectangle::readInfo(istream& in)
{
	cout << "\tEnter length ";
	in >> length;
	cout << "\tEnter width ";
	in >> width;
	string color;
	cout << "\tEnter color ";
	in >> color;
	this->setColor(color);
}
void Rectangle::printInfo(ostream& out) const
{
	out << setw(17) << getType() + " " + getColor();
	out << "Area = " << setw(9) << setprecision(2) << getArea();
	out << "Per. = " << setw(9) << setprecision(2) << getPerimeter();
	out << "Length = " << setw(7) << setprecision(2) << length;
	out << "Width = " << setw(5) << setprecision(2) << width;
}

class Square : public Rectangle
{
public:
	Square();
	Square(const double&, const string&);

	double getSide() const;

	virtual void setLength(const double&);
	virtual void setWidth(const double&);
	void setSide(const double&);

	virtual void readInfo(istream&);
	virtual void printInfo(ostream&) const;
};

Square::Square() : Rectangle() { }
Square::Square(const double& side, const string& c) : Rectangle(side, side, c) { }
double Square::getSide() const
{
	return getLength();
}
void Square::setLength(const double& len)
{
	setSide(len);
}
void Square::setWidth(const double& wid)
{
	setSide(wid);
}
void Square::setSide(const double& side)
{
	this->Rectangle::setLength(side);
	this->Rectangle::setWidth(side);
}
void Square::readInfo(istream& in)
{
	double side;
	cout << "\tEnter side ";
	in >> side;
	this->setSide(side);
	string color;
	cout << "\tEnter color ";
	in >> color;
	this->setColor(color);
}
void Square::printInfo(ostream& out) const
{
	out << setw(17) << getType() + " " + getColor();
	out << "Area = " << setw(9) << setprecision(2) << getArea();
	out << "Per. = " << setw(9) << setprecision(2) << getPerimeter();
	out << "Side = " << setw(9) << setprecision(2) << getLength();
}

class Triangle : public Shape
{
private:
	double base, height;
public:
	Triangle();
	Triangle(const double&, const double&, const string&);

	double getBase() const;
	double getHeight() const;

	void setBase(const double&);
	void setHeight(const double&);

	virtual double getArea() const;
	virtual double getPerimeter() const;

	virtual void readInfo(istream&);
	virtual void printInfo(ostream&) const;
};

Triangle::Triangle() : Shape()
{
	base = 0;
	height = 0;
}
Triangle::Triangle(const double& b, const double& h, const string& c) : Shape(c)
{
	base = b;
	height= h;
}
double Triangle::getBase() const { return base; }
double Triangle::getHeight() const { return height; }
void Triangle::setBase(const double& b) { base = b; }
void Triangle::setHeight(const double& h) { height = h; }
double Triangle::getArea() const
{
	return 0.5*base*height;
}
double Triangle::getPerimeter() const
{
	return base+height+sqrt(base*base + height*height);
}
void Triangle::readInfo(istream& in)
{
	cout << "\tEnter base ";
	in >> base;
	cout << "\tEnter height ";
	in >> height;
	string color;
	cout << "\tEnter color ";
	in >> color;
	this->setColor(color);
}
void Triangle::printInfo(ostream& out) const
{
	out << setw(17) << getType() + " " + getColor();
	out << "Area = " << setw(9) << setprecision(2) << getArea();
	out << "Per. = " << setw(9) << setprecision(2) << getPerimeter();
	out << "Base = " << setw(9) << setprecision(2) << base;
	out << "Height = " << setw(5) << setprecision(2) << height;
}

class Circle : public Shape
{
private:
	double radius;
public:
	Circle();
	Circle(const double&, const string&);

	double getRadius() const;

	void setRadius(const double&);

	virtual double getArea() const;
	virtual double getPerimeter() const;

	virtual void readInfo(istream&);
	virtual void printInfo(ostream&) const;
};
Circle::Circle() : Shape()
{
	radius = 0;
}
Circle::Circle(const double& r, const string& c) : Shape(c)
{
	radius = r;
}
double Circle::getRadius() const
{
	return radius;
}
void Circle::setRadius(const double& r)
{
	radius = r;
}
double Circle::getArea() const
{
	return PI*radius*radius;
}
double Circle::getPerimeter() const
{
	return 2*PI*radius;
}
void Circle::readInfo(istream& in)
{
	cout << "\tEnter radius ";
	in >> radius;
	string color;
	cout << "\tEnter color ";
	in >> color;
	this->setColor(color);
}
void Circle::printInfo(ostream& out) const
{
	out << setw(17) << getType() +" " +getColor();
	out << "Area = " << setw(9) << setprecision(2) << getArea();
	out << "Per. = " << setw(9) << setprecision(2) << getPerimeter();
	out << "Radius = " << setw(7) << setprecision(2) << radius;
}

class Node
{
typedef Node* NodePtr;
private:
	ShapePtr data;
	NodePtr link;
public:
	Node();
	Node(const ShapePtr&);
	Node(const Node&);
	~Node();
	ShapePtr getData() const;
	NodePtr getLink() const;
	void setData(const ShapePtr&);
	void setLink(const NodePtr&);
	friend ostream& operator<< (ostream&, const Node&);
};

typedef Node* NodePtr;

Node::Node() : data(nullptr), link(nullptr) { }
Node::Node(const Node& n) : data(n.data), link(n.link){ }
Node::Node(const ShapePtr& d) : data(d), link(nullptr){ }
Node::~Node() { delete data; }
ShapePtr Node::getData() const { return data; }
NodePtr Node::getLink() const { return link; }
void Node::setData(const ShapePtr& d) { data = d; }
void Node::setLink(const NodePtr& p) { link = p; }
ostream& operator<< (ostream& out, const Node& n)
{
	out << *(n.data);
	return out;
}

class LinkedList
{
private:
	NodePtr head;
public:
	LinkedList();
	LinkedList(const LinkedList&);
	~LinkedList();
	LinkedList& operator= (const LinkedList&);
	int getSize() const;
	void head_insert(const ShapePtr&);
	NodePtr search_node(const ShapePtr&) const;
	void insert_after(const NodePtr&, const ShapePtr&) const;
	void remove_node(const NodePtr&);
	void remove_node(const ShapePtr&);
	void remove_all(const ShapePtr&);
	void tail_insert(const ShapePtr&);
	void insert_before(const NodePtr&, const ShapePtr&);
	void insert_increasing(const ShapePtr&);
	void insert_grouped(const ShapePtr&);
	void insert_grouped_increasing(const ShapePtr&);
	friend ostream& operator<< (ostream&, const LinkedList&); //This is already implemented for you
};

LinkedList::LinkedList()
{
	head = nullptr;
}

LinkedList::LinkedList(const LinkedList& LL) 
{
	if(this->getSize() > 0 ) 
	{
		this->~LinkedList();			// deallocating memory if the first node is already full
		head = nullptr;
	}
	
	NodePtr lastNode = nullptr;
	NodePtr temp = LL.head;
	while (temp != nullptr) {
		if (lastNode == nullptr) {
			this->head_insert(temp->getData());
			lastNode = head;
		}
		else {
			this->insert_after(lastNode, temp->getData());
			lastNode = lastNode->getLink();
		}
		temp = temp->getLink();
	}
}

LinkedList::~LinkedList()
{			// deallocating and deleting the linked list
	NodePtr temp;
	while(head != nullptr)
	{
		temp = head;
		head = head->getLink();
		temp->~Node();
	}
}

LinkedList& LinkedList::operator= (const LinkedList& LL) {
	if (this == &LL)
		return *this;
	else {
		this->~LinkedList();
		NodePtr lastNode = nullptr;
		NodePtr temp = LL.head;
		while (temp != nullptr) {
			if (lastNode == nullptr) {
				this->head_insert(temp->getData());
				lastNode = head;
			}
			else {
				this->insert_after(lastNode, temp->getData());
				lastNode = lastNode->getLink();
			}
			temp = temp->getLink();
		}
			return *this;
	}
}

int LinkedList::getSize() const {				// returns size of linked list
	if(this->head == nullptr)
		return 0;
	int count = 1;
	NodePtr temp = head;
	while(temp->getLink() != nullptr) {
		temp = temp->getLink();
		count++;
	}
	return count;
}

void LinkedList::head_insert(const ShapePtr& value) {
	NodePtr n = new Node(value);
	n->setLink(head);
	head = n;
}


NodePtr LinkedList::search_node(const ShapePtr& value) const {
	NodePtr temp = head;
	while(temp != nullptr)
	{
		if (temp->getData() == value)
			return temp;
		else
			temp = temp->getLink();
	}
	return nullptr;
}

void LinkedList::insert_after(const NodePtr& n, const ShapePtr& value) const {
	if (n == nullptr)
		return;			// we don't know where to insert after?
	else {
		NodePtr temp = new Node(value);
		temp->setLink(n->getLink());
		n->setLink(temp);
	}
}

void LinkedList::tail_insert(const ShapePtr& value) {
	if (head == nullptr)
		head_insert(value);
	else {
		NodePtr b = head; //Here b is guaranteed to be not nullptr
		while(b->getLink() != nullptr)
			b = b->getLink();
		insert_after(b, value);			//easy-peasy
	}
}

void LinkedList::remove_node(const NodePtr& n)	{
	if (head == nullptr || n == nullptr) //empty linked list or nullptr n
		return;
	else if (head == n)	{
		head = head->getLink();
		delete n;
		return;
	}
	else {
		NodePtr b = head;
		while (b != nullptr) { //Here b is guaranteed to be not nullptr
			if (b->getLink() == n) {//found the node before n
				b->setLink(n->getLink());
				delete n;
				return;
			}
		b = b->getLink();
		}
	}
}

void LinkedList::remove_node(const ShapePtr& value) {
	NodePtr n = this->search_node(value);
	this->remove_node(n);
}

void LinkedList::remove_all(const ShapePtr& value) {
	NodePtr n;
	do {
		n = this->search_node(value);
		this->remove_node(n);	// easy - peasy
	} while (n != nullptr);
}

void LinkedList::insert_before(const NodePtr& n, const ShapePtr& value) {
//If the linked list is empty then insert only if n is nullptr too
	if (head == nullptr) {
		if (n == nullptr)
			this->head_insert(value);
		else
			cout << "Insertion failed. Bad node argument." << endl;
		return;
	}
//If n is nullptr then tail_insert
	if (n == nullptr) 
	{
		this->tail_insert(value);
		return;
	}
//If head is equal to n then head_insert
	if (head == n) {
		this->head_insert(value);
		return;
	}
//Find the node just before n and insert after it
	NodePtr b = head;
	while (b != nullptr) {
		if (b->getLink() == n)
		break;
		b = b->getLink();
	}
	if (b == nullptr)
		cout << "Insertion failed. Bad node argument." << endl;
	else
		insert_after(b, value);
}	

void LinkedList::insert_increasing(const ShapePtr& value) {
//Find the node before which to insert
	NodePtr n = head;
	while (n != nullptr) {
		if (n->getData()->getArea() >= value->getArea())
			break;
		n = n->getLink();
	}
//Now, insert before n
	this->insert_before(n,value);
}

void LinkedList::insert_grouped(const ShapePtr &Value) {
	if (this->getSize()==0) {
		this->head_insert(Value);
		return;
	}
		
	NodePtr temp = head;
	while (temp!=nullptr) {
		if(temp->getData()->getType() == Value->getType()) 
			break;
		else
			temp = temp->getLink();
	}
	this->insert_before(temp,Value);
}

void LinkedList::insert_grouped_increasing(const ShapePtr &kanye) {
	if(this->getSize() == 0) {
		this->head_insert(kanye);
		return;
	}
	bool flag=0;
	NodePtr temp = this->head;
	while(temp != nullptr) {
		while(temp!=nullptr && temp->getData()->getType() == kanye->getType())  {
			flag=1;
			if(temp->getData()->getArea() >= kanye->getArea()) 
				break;
			temp = temp->getLink();
		}
		if(flag==1) break;
		temp = temp->getLink();
	}
	this->insert_before(temp,kanye);
}

ostream& operator<< (ostream& out, const LinkedList& LL)
{
	NodePtr temp = LL.head;
	while(temp != nullptr)
	{
		out << *temp << endl;
		temp = temp->getLink();
	}
	return out;
}



ShapePtr getRandomShape()
{
	string ColorArray[] = {"Red", "White", "Green", "Yellow", "Black", "Orange", "Brown", "Grey", "Purple", "Blue"};
	int r = rand() % 4;
	switch (r)
	{
		case 0:
			return new Rectangle(rand()%5+1, rand()%5+1, ColorArray[rand()%10]);
		case 1:
			return new Triangle(rand()%5+1, rand()%5+1, ColorArray[rand()%10]);
		case 2:
			return new Circle(rand()%5+1, ColorArray[rand()%10]);
		default:
			return new Square(rand()%5+1, ColorArray[rand()%10]);
	}
}
